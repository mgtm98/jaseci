"""Remove empty parentheses from function signatures with no parameters."""
impl JacAutoLintPass.exit_ability(
    self: JacAutoLintPass, ability_node: uni.Ability
) -> None {
    if not self.lint_enabled {
        return;
    }
    sig = ability_node.signature;
    if not isinstance(sig, uni.FuncSignature) {
        return;
    }
    self._remove_empty_parens_from_sig(ability_node, sig, "signature");
}

"""Remove @staticmethod decorator tokens and add static keyword to ability's kid list.

This preserves original token objects (for comment associations) while
removing only the @staticmethod decorator tokens and inserting the static keyword.
"""
impl JacAutoLintPass._remove_staticmethod_from_kids(
    self: JacAutoLintPass, ability_node: uni.Ability
) -> None {
    new_kids: list[uni.UniNode] = [];
    i = 0;
    kids = ability_node.kid;
    skip_next_ws = False;
    has_static_kw = False;
    staticmethod_loc: (uni.Name | None) = None;
    # First pass: check if static keyword already exists and find @staticmethod location
    for kid in kids {
        if isinstance(kid, uni.Token) and kid.name == Tok.KW_STATIC {
            has_static_kw = True;
        }
        if isinstance(kid, uni.Name) and kid.value == "staticmethod" {
            staticmethod_loc = kid;
        }
    }
    while i < len(kids) {
        kid = kids[i];

        # Check for @ followed by staticmethod Name
        if (isinstance(kid, uni.Token) and kid.value == "@" and (i + 1) < len(kids)) {
            next_kid = kids[i + 1];
            if isinstance(next_kid, uni.Name) and next_kid.value == "staticmethod" {
                # Skip both @ and staticmethod
                i += 2;
                skip_next_ws = True;
                continue;
            }
        }

        # Skip whitespace/newline after removed decorator
        if skip_next_ws and isinstance(kid, uni.Token) {
            if kid.name in ("WS", "NL", "NEWLINE") or kid.value in ("\n", " ", "") {
                i += 1;
                skip_next_ws = False;
                continue;
            }
        }
        skip_next_ws = False;

        # Insert static keyword before def/can if not already present
        if (
            not has_static_kw
            and isinstance(kid, uni.Token)
            and kid.name in (Tok.KW_DEF, Tok.KW_CAN)
        ) {
            static_kw = ability_node.gen_token(Tok.KW_STATIC);
            # Copy location from @staticmethod for comment association
            if staticmethod_loc {
                static_kw.line_no = staticmethod_loc.loc.first_line;
                static_kw.c_start = staticmethod_loc.loc.col_start;
                static_kw.c_end = static_kw.c_start + len("static");
            }
            new_kids.append(static_kw);
            has_static_kw = True;
        }

        new_kids.append(kid);
        i += 1;
    }
    ability_node.kid = new_kids;
}

"""Process ability to convert @staticmethod decorator to static keyword and __init__/__post_init__ to init/postinit."""
impl JacAutoLintPass.enter_ability(
    self: JacAutoLintPass, ability_node: uni.Ability
) -> None {
    if not self.lint_enabled {
        return;
    }
    # Handle @staticmethod decorator conversion
    if ability_node.decorators {
        has_staticmethod = False;
        for dec in ability_node.decorators {
            if isinstance(dec, uni.Name) and dec.value == "staticmethod" {
                has_staticmethod = True;
                break;
            }
        }
        if has_staticmethod {
            # Set static flag if not already set
            if not ability_node.is_static {
                ability_node.is_static = True;
            }
            # Remove @staticmethod from decorators list
            new_decorators: list[uni.Expr] = [
                dec
                for dec in ability_node.decorators
                if not (isinstance(dec, uni.Name) and dec.value == "staticmethod")
            ];
            ability_node.decorators = new_decorators or None;
        }
    }
    # Surgically remove @staticmethod tokens from kids list
    # (preserves original tokens for comment associations)
    if ability_node.is_static {
        self._remove_staticmethod_from_kids(ability_node);
    }
    # Handle __init__ and __post_init__ conversion
    if not ability_node.is_method {
        return;
    }
    if not isinstance(ability_node.name_ref, uni.Name)
    or isinstance(ability_node.name_ref, uni.SpecialVarRef) {
        return;
    }
    new_tok: Tok | None = None;
    if ability_node.name_ref.value == "__init__" {
        new_tok = Tok.KW_INIT;
    } elif ability_node.name_ref.value == "__post_init__" {
        new_tok = Tok.KW_POST_INIT;
    }
    if new_tok is not None {
        old_ref = ability_node.name_ref;
        old_ref.name = new_tok.value;
        old_ref.value = new_tok.value;
        special_ref = uni.SpecialVarRef(var=old_ref);
        special_ref.parent = ability_node;
        ability_node.name_ref = special_ref;
        ability_node.name_spec = special_ref;
        for (idx, kid) in enumerate(ability_node.kid) {
            if kid is old_ref {
                ability_node.kid[idx] = special_ref;
                break;
            }
        }
    }
}

"""Process ImplDef to combine consecutive has statements."""
impl JacAutoLintPass.enter_impl_def(self: JacAutoLintPass, node: uni.ImplDef) -> None {
    if not self.lint_enabled {
        return;
    }
    impl_node = node;
    # Fix signature mismatch between decl and impl
    self._fix_impl_signature_mismatch(impl_node);
    # Combine consecutive has statements
    if impl_node.body is not None and isinstance(impl_node.body, list) {
        new_body = self.combine_consecutive_has(list(impl_node.body));
        if len(new_body) != len(impl_node.body) {
            impl_node.body = new_body;
            self.recalculate_parents(impl_node);
        }
    }
}

"""Remove empty parentheses from impl signatures with no parameters."""
impl JacAutoLintPass.exit_impl_def(self: JacAutoLintPass, <>node: uni.ImplDef) -> None {
    if not self.lint_enabled {
        return;
    }
    spec = <>node.spec;
    if not isinstance(spec, uni.FuncSignature) {
        return;
    }
    self._remove_empty_parens_from_sig(<>node, spec, "spec");
}

"""Process Enum to combine consecutive has statements."""
impl JacAutoLintPass.enter_enum(self: JacAutoLintPass, node: uni.Enum) -> None {
    if not self.lint_enabled {
        return;
    }
    enum_node = node;
    if enum_node.body is not None and isinstance(enum_node.body, list) {
        new_body = self.combine_consecutive_has(list(enum_node.body));
        if len(new_body) != len(enum_node.body) {
            enum_node.body = new_body;
            self.recalculate_parents(enum_node);
            enum_node.normalize(deep=False);
        }
    }
}

"""Process Archetype to combine consecutive has statements."""
impl JacAutoLintPass.enter_archetype(
    self: JacAutoLintPass, node: uni.Archetype
) -> None {
    if not self.lint_enabled {
        return;
    }
    arch = node;
    if arch.body is not None and isinstance(arch.body, list) {
        new_body = self.combine_consecutive_has(list(arch.body));
        if len(new_body) != len(arch.body) {
            arch.body = new_body;
            self.recalculate_parents(arch);
            arch.normalize(deep=False);
        }
    }
}

"""Combine consecutive glob statements in a body list."""
impl JacAutoLintPass.combine_consecutive_glob(
    self: JacAutoLintPass, body: list
) -> list {
    if len(body) <= 1 {
        return body;
    }
    new_body: list[uni.UniNode] = [];
    i = 0;
    while i < len(body) {
        stmt = body[i];

        if isinstance(stmt, uni.GlobalVars) {
            # Start collecting consecutive compatible glob statements
            combined_assignments: list = list(stmt.assignments);
            combined_doc = stmt.doc;
            base_glob = stmt;
            j = i + 1;
            while j < len(body) {
                next_stmt = body[j];
                if isinstance(next_stmt, uni.GlobalVars)
                and self.can_combine_glob(base_glob, next_stmt) {
                    # Combine the assignments
                    combined_assignments.extend(next_stmt.assignments);
                    j += 1;
                } else {
                    break;
                }
            }
            # If we combined multiple glob statements, create new one
            if j > i + 1 {
                new_glob = uni.GlobalVars(
                    access=base_glob.access,
                    assignments=combined_assignments,
                    is_frozen=base_glob.is_frozen,
                    kid=combined_assignments,
                    doc=combined_doc
                );
                new_glob.normalize(deep=True);
                new_body.append(new_glob);
            } else {
                new_body.append(stmt);
            }
            i = j;
        } else {
            new_body.append(stmt);
            i += 1;
        }
    }
    return new_body;
}

"""Combine consecutive has statements in a body list."""
impl JacAutoLintPass.combine_consecutive_has(self: JacAutoLintPass, body: list) -> list {
    if len(body) <= 1 {
        return body;
    }
    new_body: list[uni.UniNode] = [];
    i = 0;
    while i < len(body) {
        stmt = body[i];

        if isinstance(stmt, uni.ArchHas) {
            # Start collecting consecutive compatible has statements
            combined_vars: list = list(stmt.vars);
            combined_doc = stmt.doc;
            base_has = stmt;
            j = i + 1;
            while j < len(body) {
                next_stmt = body[j];
                if isinstance(next_stmt, uni.ArchHas)
                and self.can_combine_has(base_has, next_stmt) {
                    # Combine the vars
                    combined_vars.extend(next_stmt.vars);
                    j += 1;
                } else {
                    break;
                }
            }
            # If we combined multiple has statements, create new one
            if j > i + 1 {
                new_has = uni.ArchHas(
                    is_static=base_has.is_static,
                    access=base_has.access,
                    vars=combined_vars,
                    is_frozen=base_has.is_frozen,
                    kid=combined_vars,
                    doc=combined_doc
                );
                new_has.normalize(deep=True);
                new_body.append(new_has);
            } else {
                new_body.append(stmt);
            }
            i = j;
        } else {
            new_body.append(stmt);
            i += 1;
        }
    }
    return new_body;
}

"""Check if two GlobalVars nodes can be combined (same access, frozen)."""
impl JacAutoLintPass.can_combine_glob(
    self: JacAutoLintPass, glob1: uni.GlobalVars, glob2: uni.GlobalVars
) -> bool {
    # Must have same frozen modifier
    if glob1.is_frozen != glob2.is_frozen {
        return False;
    }
    # Must have same access modifier
    access1 = glob1.access.tag.name if glob1.access else None;
    access2 = glob2.access.tag.name if glob2.access else None;
    if access1 != access2 {
        return False;
    }
    return True;
}

"""Check if two ArchHas nodes can be combined (same static, access, frozen)."""
impl JacAutoLintPass.can_combine_has(
    self: JacAutoLintPass, has1: uni.ArchHas, has2: uni.ArchHas
) -> bool {
    # Must have same static modifier
    if has1.is_static != has2.is_static {
        return False;
    }
    # Must have same frozen modifier
    if has1.is_frozen != has2.is_frozen {
        return False;
    }
    # Must have same access modifier
    access1 = has1.access.tag.name if has1.access else None;
    access2 = has2.access.tag.name if has2.access else None;
    if access1 != access2 {
        return False;
    }
    return True;
}

"""Create a new ModuleCode (with entry) block from a list of statements."""
impl JacAutoLintPass.create_entry_block(
    self: JacAutoLintPass, stmts: list
) -> uni.ModuleCode {
    entry_block = uni.ModuleCode(name=None, body=stmts, kid=stmts, doc=None);
    # Normalize shallowly - generates with entry tokens but preserves child loc info
    entry_block.normalize(deep=False);
    return entry_block;
}

"""Create a GlobalVars node from an assignment."""
impl JacAutoLintPass.create_glob_from_assignment(
    self: JacAutoLintPass, assignment: uni.Assignment
) -> uni.GlobalVars {
    glob_node = uni.GlobalVars(
        access=None,
        assignments=[assignment],
        is_frozen=False,
        kid=[assignment],
        doc=None
    );
    # Normalize shallowly - generates glob keyword but preserves child loc info
    glob_node.normalize(deep=False);
    return glob_node;
}

"""Check if a statement is a module-level construct that can be extracted."""
impl JacAutoLintPass.is_module_level_construct(
    self: JacAutoLintPass, stmt: uni.UniNode
) -> bool {
    # These types can exist at module level and should be extracted
    return isinstance(
        stmt,
        (
            uni.Import,
            uni.Archetype,
            uni.Ability,
            uni.Enum,
            uni.GlobalVars,
            uni.Test,
            uni.PyInlineCode
        )
    );
}

"""Check if an assignment can be converted to glob."""
impl JacAutoLintPass.can_convert_to_glob(
    self: JacAutoLintPass, assignment: uni.Assignment
) -> bool {
    # Must have a value (not just declaration)
    if assignment.value is None {
        return False;
    }
    # Must not be an augmented assignment (+=, -= etc.)
    if assignment.aug_op is not None {
        return False;
    }
    # All targets must be simple names
    for target in assignment.target {
        if not isinstance(target, uni.Name) {
            return False;
        }
    }
    return True;
}

"""Process module to transform with entry blocks in-place."""
impl JacAutoLintPass.enter_module(self: JacAutoLintPass, node: uni.Module) -> None {
    if not self.lint_enabled {
        return;
    }
    module = node;
    # Store main module reference (first module, not impl modules)
    if self.main_module is None {
        self.main_module = module;
        # Process impl modules after setting main_module
        for impl_mod in module.impl_mod {
            self.traverse(impl_mod);
        }
    }
    # Transform module body in-place
    new_body: list[uni.UniNode] = [];
    for stmt in module.body {
        # Remove `import from __future__ { annotations }` - not needed in Jac
        if self._is_future_annotations_import(stmt) {
            continue;
        }
        if isinstance(stmt, uni.ModuleCode) and stmt.name is None {
            # Unnamed with entry block - extract module-level constructs
            # while preserving order for correctness
            pending_entry_stmts: list[uni.UniNode] = [];
            for inner_stmt in stmt.body {
                # Check if this statement should be extracted to module level
                extracted_stmt: uni.UniNode | None = None;
                if isinstance(inner_stmt, uni.Assignment)
                and self.can_convert_to_glob(inner_stmt) {
                    extracted_stmt = self.create_glob_from_assignment(inner_stmt);
                } elif self.is_module_level_construct(inner_stmt) {
                    extracted_stmt = inner_stmt;
                }

                if extracted_stmt is not None {
                    # Flush pending entry statements first to preserve order
                    if pending_entry_stmts {
                        new_body.append(self.create_entry_block(pending_entry_stmts));
                        pending_entry_stmts = [];
                    }
                    new_body.append(extracted_stmt);
                } elif not isinstance(inner_stmt, uni.Semi) {
                    # Accumulate non-module-level statements for with entry
                    pending_entry_stmts.append(inner_stmt);
                }
            }
            # Flush any remaining pending entry statements
            if pending_entry_stmts {
                new_body.append(self.create_entry_block(pending_entry_stmts));
            }
        } else {
            new_body.append(stmt);
        }
    }
    # Combine consecutive glob statements with same modifiers
    new_body = self.combine_consecutive_glob(new_body);
    module.body = new_body;
    self.recalculate_parents(module);
    module.normalize(deep=False);
}

"""Remove unnecessary angle bracket escaping from names that are not actual keywords.

Names only need angle bracket escaping if they conflict with:
- Python keywords (and, or, if, else, etc.)
- Jac reserved keywords from the grammar

This also handles SpecialVarRef where the underlying name should
never have angle bracket escaping since it's already recognized as a special keyword.
"""
impl JacAutoLintPass.enter_name(self: JacAutoLintPass, <>node: uni.Name) -> None {
    if not self.lint_enabled {
        return;
    }
    # Skip if not escaped or if it's a SpecialVarRef (handled separately)
    if not <>node.is_kwesc or isinstance(<>node, uni.SpecialVarRef) {
        return;
    }
    jac_keywords = set(TOKEN_MAP.values());
    python_keywords = set(keyword.kwlist);
    reserved = jac_keywords | python_keywords;
    # If the name value is NOT a reserved keyword, remove the angle bracket escape
    if <>node.value not in reserved {
        <>node.is_kwesc = False;
        # Also update the token name from KWESC_NAME to NAME
        if <>node.name == Tok.KWESC_NAME {
            <>node.name = Tok.NAME;
        }
    }
}

"""Remove angle bracket escaping from SpecialVarRef's underlying name.

SpecialVarRef wraps special keywords like init, postinit, self, super,
root, here, visitor. The underlying Name should never have angle bracket escaping
since these are already recognized as special tokens in the grammar.
"""
impl JacAutoLintPass.enter_special_var_ref(
    self: JacAutoLintPass, <>node: uni.SpecialVarRef
) -> None {
    if not self.lint_enabled {
        return;
    }
    if <>node.orig.is_kwesc {
        <>node.orig.is_kwesc = False;
        if <>node.orig.name == Tok.KWESC_NAME {
            <>node.orig.name = Tok.NAME;
        }
    }
    # Also check if the SpecialVarRef itself has is_kwesc set (it inherits from Name)
    if <>node.is_kwesc {
        <>node.is_kwesc = False;
    }
}

"""Remove angle bracket escaping from BuiltinType nodes.

BuiltinType represents built-in types like str, int, float, bool, etc.
These should never have angle bracket escaping since they are recognized as
built-in type tokens in the grammar.
"""
impl JacAutoLintPass.enter_builtin_type(
    self: JacAutoLintPass, <>node: uni.BuiltinType
) -> None {
    if not self.lint_enabled {
        return;
    }
    # BuiltinType inherits from Name, so it has is_kwesc
    # Built-in types should never be escaped
    if <>node.is_kwesc {
        <>node.is_kwesc = False;
        if <>node.name == Tok.KWESC_NAME {
            <>node.name = Tok.NAME;
        }
    }
}

"""Convert hasattr(obj, "attr") to null-safe access.

This helper checks if a FuncCall is a hasattr call with exactly two arguments:
- First arg: any expression (the object)
- Second arg: a string literal (the attribute name)

If valid, creates and returns an AtomTrailer with is_null_ok=True.
Returns None if the call doesn't match the hasattr pattern.
"""
impl JacAutoLintPass._convert_hasattr_to_null_ok(
    self: JacAutoLintPass, node: uni.FuncCall
) -> (uni.AtomTrailer | None) {
    # Check if target is a Name with value "hasattr"
    if not isinstance(node.target, uni.Name) {
        return None;
    }
    if node.target.value != "hasattr" {
        return None;
    }
    # Must have exactly 2 parameters
    if len(node.params) != 2 {
        return None;
    }
    obj_expr = node.params[0];
    attr_expr = node.params[1];
    # Second parameter must be a string literal
    # Handle both String and MultiString (which wraps String)
    attr_value: str | None = None;
    string_node: uni.String | None = None;
    if isinstance(attr_expr, uni.String) {
        attr_value = attr_expr.value;
        string_node = attr_expr;
    } elif isinstance(attr_expr, uni.MultiString) {
        # MultiString contains a list of String/FString
        # For hasattr, we only handle simple single strings
        if len(attr_expr.strings) == 1 and isinstance(attr_expr.strings[0], uni.String) {
            attr_value = attr_expr.strings[0].value;
            string_node = attr_expr.strings[0];
        }
    }
    if attr_value is None or string_node is None {
        return None;
    }
    # Extract attribute name from string (remove quotes)
    if (attr_value.startswith('"') and attr_value.endswith('"'))
    or (attr_value.startswith("'") and attr_value.endswith("'")) {
        attr_name = attr_value[1:-1];
    } else {
        return None;
    }
    # Create a Name node for the attribute using the string node's location info
    attr_name_node = uni.Name(
        orig_src=string_node.loc.orig_src,
        name=Tok.NAME.name,
        value=attr_name,
        line=string_node.loc.first_line,
        end_line=string_node.loc.last_line,
        col_start=string_node.loc.col_start,
        col_end=string_node.loc.col_end,
        pos_start=string_node.loc.pos_start,
        pos_end=string_node.loc.pos_end,
        is_kwesc=False
    );
    # Create the null-safe AtomTrailer (obj null-safe attr)
    null_ok_access = uni.AtomTrailer(
        target=obj_expr,
        right=attr_name_node,
        is_attr=True,
        is_null_ok=True,
        kid=[obj_expr, attr_name_node]
    );
    null_ok_access.normalize(deep=False);
    return null_ok_access;
}

"""Check if an AtomTrailer matches an object and attribute name.

Returns True if the AtomTrailer represents obj.attr where obj matches
the given object expression and attr matches the given attribute name.
"""
impl JacAutoLintPass._is_matching_attr_access(
    self: JacAutoLintPass, trailer: uni.AtomTrailer, obj_expr: uni.Expr, attr_name: str
) -> bool {
    # Must be an attribute access (not subscript)
    if not trailer.is_attr {
        return False;
    }
    # The right side must be a Name matching the attribute
    if not isinstance(trailer.right, uni.Name) {
        return False;
    }
    if trailer.right.value != attr_name {
        return False;
    }
    # The target must match the object expression
    # Use structural comparison to avoid corrupting locations via unparse()
    return self._exprs_are_identical(obj_expr, trailer.target);
}

"""Convert an AtomTrailer to use null-safe access.

Takes an existing obj.attr AtomTrailer and converts it to use null-safe access
by setting is_null_ok=True and re-normalizing.
"""
impl JacAutoLintPass._make_null_ok(
    self: JacAutoLintPass, trailer: uni.AtomTrailer
) -> None {
    if not trailer.is_null_ok {
        trailer.is_null_ok = True;
        trailer.normalize(deep=False);
    }
}

"""Process FuncCall to convert hasattr(obj, "attr") to null-safe access.

This replaces hasattr calls in the parent node's children with
the equivalent null-safe access expression.

For IfElseExpr patterns like obj.attr if hasattr(obj, "attr") else default,
this also converts the value expression to use null-safe access.
"""
impl JacAutoLintPass.exit_func_call(self: JacAutoLintPass, node: uni.FuncCall) -> None {
    if not self.lint_enabled {
        return;
    }
    # Try to convert hasattr to null-safe access
    replacement = self._convert_hasattr_to_null_ok(node);
    if replacement is None {
        return;
    }
    # Extract obj and attr from the hasattr call for pattern matching
    obj_expr = node.params[0];
    attr_expr = node.params[1];
    attr_name = self._extract_string_literal_value(attr_expr);
    # Replace this node in its parent
    parent = node.parent;
    if parent is None {
        return;
    }
    replacement.parent = parent;
    # Find and replace in parent's children
    # Handle different parent types that might contain this FuncCall
    if isinstance(parent, uni.IfElseExpr) {
        if parent.condition is node {
            parent.condition = replacement;
            # Also check if value is obj.attr matching the hasattr pattern
            # Pattern: obj.attr if hasattr(obj, "attr") else default
            # Convert to: null-safe access if null-safe access else default
            if attr_name is not None and isinstance(parent.value, uni.AtomTrailer) {
                if self._is_matching_attr_access(parent.value, obj_expr, attr_name) {
                    self._make_null_ok(parent.value);
                }
            }
        } elif parent.value is node {
            parent.value = replacement;
        } elif parent.else_value is node {
            parent.else_value = replacement;
        }
        parent.normalize(deep=False);
    } elif isinstance(parent, uni.BinaryExpr) {
        if parent.left is node {
            parent.left = replacement;
        } elif parent.right is node {
            parent.right = replacement;
        }
        parent.normalize(deep=False);
    } elif isinstance(parent, uni.BoolExpr) {
        # BoolExpr has a values list (for 'and'/'or' expressions)
        new_values: list[uni.Expr] = [];
        for val in parent.values {
            if val is node {
                new_values.append(replacement);
            } else {
                new_values.append(val);
            }
        }
        parent.values = new_values;
        parent.normalize(deep=False);
    } elif isinstance(parent, uni.UnaryExpr) {
        if parent.operand is node {
            parent.operand = replacement;
        }
        parent.normalize(deep=False);
    } elif isinstance(parent, uni.IfStmt) {
        if parent.condition is node {
            parent.condition = replacement;
        }
        parent.normalize(deep=False);
    } elif isinstance(parent, uni.WhileStmt) {
        if parent.condition is node {
            parent.condition = replacement;
        }
        parent.normalize(deep=False);
    } else {
        # For other parent types, update kid list manually
        new_kids: list[uni.UniNode] = [];
        for kid in parent.kid {
            if kid is node {
                new_kids.append(replacement);
            } else {
                new_kids.append(kid);
            }
        }
        parent.kid = new_kids;
    }
}

"""Recursively collect all AtomTrailer nodes from a subtree."""
impl JacAutoLintPass._collect_atom_trailers(
    self: JacAutoLintPass, uni_node: uni.UniNode, results: list
) -> None {
    if isinstance(uni_node, uni.AtomTrailer) {
        results.append(uni_node);
    }
    if uni_node?.kid {
        for kid in uni_node.kid {
            if kid is not None {
                self._collect_atom_trailers(kid, results);
            }
        }
    }
}

"""Build a string key from an expression without calling unparse().

This avoids triggering normalize() which corrupts token locations.
Returns None if the expression is too complex to build a key from.
"""
impl JacAutoLintPass._expr_to_key(
    self: JacAutoLintPass, expr: uni.Expr
) -> (str | None) {
    if isinstance(expr, uni.Name) {
        return expr.value;
    }
    if isinstance(expr, uni.AtomTrailer) {
        if expr.is_attr and isinstance(expr.right, uni.Name) {
            target_key = self._expr_to_key(expr.target);
            if target_key is not None {
                null_ok = "?" if expr.is_null_ok else "";
                return f"{target_key}{null_ok}.{expr.right.value}";
            }
        }
        return None;
    }
    if isinstance(expr, uni.SpecialVarRef) {
        return expr.name.value if expr.name else None;
    }
    # For other expression types, return None (too complex)
    return None;
}

"""Get a unique key for an AtomTrailer based on its target and attribute.

Returns a string like "obj.attr" that can be used to identify matching accesses.
Returns None if the trailer is not a simple attribute access.
"""
impl JacAutoLintPass._get_trailer_key(
    self: JacAutoLintPass, trailer: uni.AtomTrailer
) -> (str | None) {
    if not trailer.is_attr {
        return None;
    }
    if not isinstance(trailer.right, uni.Name) {
        return None;
    }
    attr_name = trailer.right.value;
    # Build key from target without calling unparse()
    target_key = self._expr_to_key(trailer.target);
    if target_key is not None {
        null_ok = "?" if trailer.is_null_ok else "";
        return f"{target_key}{null_ok}.{attr_name}";
    }
    return None;
}

"""Check if two expressions are structurally identical without calling unparse().

This avoids triggering normalize() which corrupts token locations.
"""
impl JacAutoLintPass._exprs_are_identical(
    self: JacAutoLintPass, expr1: uni.Expr, expr2: uni.Expr
) -> bool {
    # Same object reference
    if expr1 is expr2 {
        return True;
    }
    # Must be same type
    if type(expr1) != type(expr2) {
        return False;
    }
    # Compare Names by value
    if isinstance(expr1, uni.Name) and isinstance(expr2, uni.Name) {
        return expr1.value == expr2.value;
    }
    # Compare AtomTrailers recursively
    if isinstance(expr1, uni.AtomTrailer) and isinstance(expr2, uni.AtomTrailer) {
        if expr1.is_attr != expr2.is_attr {
            return False;
        }
        if expr1.is_null_ok != expr2.is_null_ok {
            return False;
        }
        if not self._exprs_are_identical(expr1.target, expr2.target) {
            return False;
        }
        if isinstance(expr1.right, uni.Name) and isinstance(expr2.right, uni.Name) {
            return expr1.right.value == expr2.right.value;
        }
        return self._exprs_are_identical(expr1.right, expr2.right);
    }
    # Compare SpecialVarRef
    if isinstance(expr1, uni.SpecialVarRef) and isinstance(expr2, uni.SpecialVarRef) {
        if expr1.name and expr2.name {
            return expr1.name.value == expr2.name.value;
        }
        return expr1.name is None and expr2.name is None;
    }
    # For other types, use key comparison as fallback
    key1 = self._expr_to_key(expr1);
    key2 = self._expr_to_key(expr2);
    if key1 is not None and key2 is not None {
        return key1 == key2;
    }
    # Cannot safely compare - assume not identical
    return False;
}

"""Convert IfElseExpr to BoolExpr with or when value equals condition.

Transforms: x?.attr if x?.attr else default -> x?.attr or default
This only applies when the value and condition are identical expressions.
"""
impl JacAutoLintPass._convert_ternary_to_or(
    self: JacAutoLintPass, if_else_node: uni.IfElseExpr
) -> bool {
    # Check if value and condition are identical
    if not self._exprs_are_identical(if_else_node.value, if_else_node.condition) {
        return False;
    }
    # Create a BoolExpr with 'or' operator: value or else_value
    or_expr = uni.BoolExpr(
        op=uni.Token(
            orig_src=if_else_node.loc.orig_src,
            name=Tok.KW_OR,
            value="or",
            line=if_else_node.loc.first_line,
            end_line=if_else_node.loc.first_line,
            col_start=0,
            col_end=2,
            pos_start=0,
            pos_end=2
        ),
        values=[if_else_node.value, if_else_node.else_value],
        kid=[if_else_node.value, if_else_node.else_value]
    );
    or_expr.normalize(deep=False);
    # Replace in parent
    parent = if_else_node.parent;
    if parent is None {
        return False;
    }
    or_expr.parent = parent;
    # Update parent's reference to this node
    if parent?.kid {
        new_kids: list[uni.UniNode] = [];
        for kid in parent.kid {
            if kid is if_else_node {
                new_kids.append(or_expr);
            } else {
                new_kids.append(kid);
            }
        }
        parent.kid = new_kids;
    }
    # Also update specific parent attributes that might reference this node
    if isinstance(parent, uni.Assignment) {
        if parent.value is if_else_node {
            parent.value = or_expr;
        }
    } elif isinstance(parent, uni.IfElseExpr) {
        if parent.value is if_else_node {
            parent.value = or_expr;
        } elif parent.condition is if_else_node {
            parent.condition = or_expr;
        } elif parent.else_value is if_else_node {
            parent.else_value = or_expr;
        }
    } elif isinstance(parent, uni.BoolExpr) {
        new_values: list[uni.Expr] = [];
        for val in parent.values {
            if val is if_else_node {
                new_values.append(or_expr);
            } else {
                new_values.append(val);
            }
        }
        parent.values = new_values;
    }
    return True;
}

"""Propagate null-safe access within IfElseExpr and simplify ternary to or.

When an expression contains both null-safe and regular accesses for the same
object and attribute, convert the regular accesses to null-safe.

Also converts patterns like: x?.attr if x?.attr else default -> x?.attr or default
"""
impl JacAutoLintPass.exit_if_else_expr(
    self: JacAutoLintPass, if_else_node: uni.IfElseExpr
) -> None {
    if not self.lint_enabled {
        return;
    }
    # First, try to convert identical ternary to or expression
    # Pattern: x?.attr if x?.attr else default -> x?.attr or default
    if self._convert_ternary_to_or(if_else_node) {
        return;
    }
    # Collect all AtomTrailers in this expression
    trailers: list[uni.AtomTrailer] = [];
    self._collect_atom_trailers(if_else_node, trailers);
    if len(trailers) < 2 {
        return;
    }
    # Find null-safe accesses and their keys
    null_ok_keys: set = set();
    for trailer in trailers {
        if isinstance(trailer, uni.AtomTrailer) and trailer.is_null_ok {
            key = self._get_trailer_key(trailer);
            if key is not None {
                null_ok_keys.add(key);
            }
        }
    }
    if not null_ok_keys {
        return;
    }
    # Convert matching non-null-safe accesses
    changed = False;
    for trailer in trailers {
        if isinstance(trailer, uni.AtomTrailer) and not trailer.is_null_ok {
            key = self._get_trailer_key(trailer);
            if key is not None and key in null_ok_keys {
                self._make_null_ok(trailer);
                changed = True;
            }
        }
    }
    if changed {
        if_else_node.normalize(deep=True);
    }
}

"""Propagate null-safe access within BoolExpr (and/or expressions).

When an expression contains both null-safe and regular accesses for the same
object and attribute, convert the regular accesses to null-safe.
"""
impl JacAutoLintPass.exit_bool_expr(
    self: JacAutoLintPass, bool_node: uni.BoolExpr
) -> None {
    if not self.lint_enabled {
        return;
    }
    # Collect all AtomTrailers in this expression
    trailers: list[uni.AtomTrailer] = [];
    self._collect_atom_trailers(bool_node, trailers);
    if len(trailers) < 2 {
        return;
    }
    # Find null-safe accesses and their keys
    null_ok_keys: set = set();
    for trailer in trailers {
        if isinstance(trailer, uni.AtomTrailer) and trailer.is_null_ok {
            key = self._get_trailer_key(trailer);
            if key is not None {
                null_ok_keys.add(key);
            }
        }
    }
    if not null_ok_keys {
        return;
    }
    # Convert matching non-null-safe accesses
    changed = False;
    for trailer in trailers {
        if isinstance(trailer, uni.AtomTrailer) and not trailer.is_null_ok {
            key = self._get_trailer_key(trailer);
            if key is not None and key in null_ok_keys {
                self._make_null_ok(trailer);
                changed = True;
            }
        }
    }
    if changed {
        bool_node.normalize(deep=True);
    }
}

"""Check if a statement is an `import from __future__ { annotations }` import.

This import is not needed in Jac since Jac already uses deferred annotation
evaluation by default. Removing it cleans up code converted from Python.
"""
impl JacAutoLintPass._is_future_annotations_import(
    self: JacAutoLintPass, stmt: uni.UniNode
) -> bool {
    if not isinstance(stmt, uni.Import) {
        return False;
    }
    import_node = stmt;
    # Must be a "from X import Y" style import (has from_loc)
    if import_node.from_loc is None {
        return False;
    }
    # Check if from_loc path is "__future__"
    from_path = import_node.from_loc.path;
    if from_path is None or len(from_path) != 1 {
        return False;
    }
    first_path = from_path[0];
    if not isinstance(first_path, uni.Name) {
        return False;
    }
    if first_path.value != "__future__" {
        return False;
    }
    # Check if items contain "annotations"
    for item in import_node.items {
        if isinstance(item, uni.ModuleItem) {
            if isinstance(item.name, uni.Name) and item.name.value == "annotations" {
                return True;
            }
        }
    }
    return False;
}

"""Fix signature mismatch between declaration and implementation.

When an impl's signature doesn't match its declaration, copy the declaration's
signature to the implementation to ensure consistency.

This works by looking up the declaration via symbol table since decl_link may
not be set yet when this pass runs during formatting.

Supports nested classes: for `impl OuterClass.InnerClass.method`, it navigates
through OuterClass -> InnerClass -> method to find the correct declaration.
"""
impl JacAutoLintPass._fix_impl_signature_mismatch(
    self: JacAutoLintPass, impl_node: uni.ImplDef
) -> None {
    # First try decl_link (if DeclImplMatchPass has already run)
    decl: uni.Ability | None = None;
    if isinstance(impl_node.decl_link, uni.Ability) {
        decl = impl_node.decl_link;
    } else {
        # Look up the declaration via symbol table
        # impl_node.target is a sequence like [Calculator, add] or
        # [OuterClass, InnerClass, method] for nested classes
        if not impl_node.target or len(impl_node.target) < 2 {
            return;
        }
        # Get the root archetype name and ability name (last element)
        root_arch_name = impl_node.target[0].sym_name if impl_node.target[0] else None;
        ability_name = impl_node.target[-1].sym_name if impl_node.target[-1] else None;
        if not root_arch_name or not ability_name {
            return;
        }
        # Use the stored main_module reference
        if self.main_module is None or not self.main_module.sym_tab {
            return;
        }
        # Look up root archetype
        arch_sym = self.main_module.sym_tab.lookup(root_arch_name);
        if not arch_sym or not arch_sym.decl {
            return;
        }
        arch_node = arch_sym.decl.name_of;
        if not isinstance(arch_node, uni.Archetype) or not arch_node.body {
            return;
        }
        # Navigate through nested classes if target has more than 2 elements
        # e.g., [OuterClass, InnerClass, method] -> navigate OuterClass -> InnerClass
        for i in range(1, len(impl_node.target) - 1) {
            nested_name = impl_node.target[i].sym_name if impl_node.target[i] else None;
            if not nested_name {
                return;
            }
            # Find the nested class in the current archetype's body
            found_nested = False;
            for member in arch_node.body {
                if isinstance(member, uni.Archetype) {
                    if member.name_spec and member.name_spec.sym_name == nested_name {
                        arch_node = member;
                        found_nested = True;
                        break;
                    }
                }
            }
            if not found_nested or not arch_node.body {
                return;
            }
        }
        # Find the ability in the (possibly nested) archetype
        for member in arch_node.body {
            if isinstance(member, uni.Ability) {
                if member.name_ref and member.name_ref.sym_name == ability_name {
                    decl = member;
                    break;
                }
            }
        }
    }
    if decl is None or decl.signature is None {
        return;
    }
    if not isinstance(impl_node.spec, uni.FuncSignature) {
        return;
    }
    # Compare signatures structurally without calling unparse/normalize
    # (unparse triggers normalize which corrupts token locations)
    decl_sig = decl.signature;
    impl_sig = impl_node.spec;
    # Check if signatures match (if they do, return early)
    if self._signatures_match(decl_sig, impl_sig) {
        return;
    }
    # Copy the declaration's signature to the impl
    import copy;
    new_sig = copy.deepcopy(decl.signature);
    new_sig.parent = impl_node;
    # Update impl_node's spec and kid list
    old_spec = impl_node.spec;
    impl_node.spec = new_sig;
    # Replace old spec in kid list with new sig
    new_kids: list[uni.UniNode] = [];
    for kid in impl_node.kid {
        if kid is old_spec {
            new_kids.append(new_sig);
        } else {
            new_kids.append(kid);
        }
    }
    impl_node.kid = new_kids;
}

"""Check if two FuncSignatures match structurally without calling unparse().

Compares parameter counts and names to determine if signatures are equivalent.
"""
impl JacAutoLintPass._signatures_match(
    self: JacAutoLintPass, decl_sig: uni.FuncSignature, impl_sig: uni.FuncSignature
) -> bool {
    # Compare parameter counts first
    if (
        len(decl_sig.params) != len(impl_sig.params)
        or len(decl_sig.posonly_params) != len(impl_sig.posonly_params)
        or len(decl_sig.kwonlyargs) != len(impl_sig.kwonlyargs)
        or (decl_sig.varargs is None) != (impl_sig.varargs is None)
        or (decl_sig.kwargs is None) != (impl_sig.kwargs is None)
        or (decl_sig.return_type is None) != (impl_sig.return_type is None)
    ) {
        return False;
    }
    # Check parameter names match
    for (i, decl_param) in enumerate(decl_sig.params) {
        impl_param = impl_sig.params[i];
        if decl_param.name.value != impl_param.name.value {
            return False;
        }
    }
    for (i, decl_param) in enumerate(decl_sig.posonly_params) {
        impl_param = impl_sig.posonly_params[i];
        if decl_param.name.value != impl_param.name.value {
            return False;
        }
    }
    for (i, decl_param) in enumerate(decl_sig.kwonlyargs) {
        impl_param = impl_sig.kwonlyargs[i];
        if decl_param.name.value != impl_param.name.value {
            return False;
        }
    }
    return True;
}

"""Remove standalone semicolons after `import from X { ... }` inside code blocks.

When users write `import from X { ... };` inside a function/ability, the semicolon
is parsed as a separate Semi statement. This removes those unnecessary semicolons.
"""
impl JacAutoLintPass.enter_import(
    self: JacAutoLintPass, import_node: uni.Import
) -> None {
    if not self.lint_enabled or import_node.from_loc is None {
        return;
    }
    parent = import_node.parent;
    if parent is None or not parent?.body or not isinstance(parent?.body, list) {
        return;
    }
    # Find if this import is followed by a Semi statement
    body = parent.body;
    try {
        idx = body.index(import_node);
    } except ValueError {
        return;
    }
    if idx + 1 < len(body) and isinstance(body[idx + 1], uni.Semi) {
        semi = body[idx + 1];
        parent.body = [
            s
            for s in body
            if s is not semi
        ];
        parent.kid = [
            k
            for k in parent.kid
            if k is not semi
        ];
    }
}

"""Remove empty parentheses from a function signature with no parameters.

This is a shared helper used by both exit_ability and exit_impl_def.
Handles both cases:
- No params, no return type: Remove the entire signature
- No params, with return type: Remove just LPAREN/RPAREN, keep return type

Args:
    target_node: The parent node (Ability or ImplDef)
    sig: The FuncSignature to modify
    sig_attr: The attribute name on the node that holds the signature
              ("signature" for Ability, "spec" for ImplDef)
"""
impl JacAutoLintPass._remove_empty_parens_from_sig(
    self: JacAutoLintPass,
    target_node: uni.UniNode,
    sig: uni.FuncSignature,
    sig_attr: str
) -> None {
    # Check if signature has any parameters
    has_params = bool(
        sig.posonly_params or sig.params or sig.varargs or sig.kwonlyargs or sig.kwargs
    );
    if has_params {
        return;
    }
    # No parameters - handle based on whether there's a return type
    if sig.return_type is None {
        # No params and no return type - remove signature entirely
        setattr(target_node, sig_attr, None);
        # Remove signature from target_node's kid list
        new_kid: list[uni.UniNode] = [];
        for kid in target_node.kid {
            if kid is not sig {
                new_kid.append(kid);
            }
        }
        target_node.kid = new_kid;
    } else {
        # Has return type - remove just the parentheses tokens
        new_kid: list[uni.UniNode] = [];
        for kid in sig.kid {
            if isinstance(kid, uni.Token) and kid.name in (Tok.LPAREN, Tok.RPAREN) {
                continue;
            }
            new_kid.append(kid);
        }
        if len(new_kid) != len(sig.kid) and len(new_kid) > 0 {
            sig.set_kids(nodes=new_kid);
        }
    }
}

"""Extract the string value from a String or MultiString expression.

Returns the unquoted string value, or None if the expression is not a simple string literal.
Used by hasattr conversion to extract attribute names.
"""
impl JacAutoLintPass._extract_string_literal_value(
    self: JacAutoLintPass, expr: uni.Expr
) -> (str | None) {
    attr_value: str | None = None;
    if isinstance(expr, uni.String) {
        attr_value = expr.value;
    } elif isinstance(expr, uni.MultiString) {
        # MultiString contains a list of String/FString
        # For hasattr, we only handle simple single strings
        if len(expr.strings) == 1 and isinstance(expr.strings[0], uni.String) {
            attr_value = expr.strings[0].value;
        }
    }
    if attr_value is None {
        return None;
    }
    # Remove quotes from string value
    if (attr_value.startswith('"') and attr_value.endswith('"'))
    or (attr_value.startswith("'") and attr_value.endswith("'")) {
        return attr_value[1:-1];
    }
    return None;
}
